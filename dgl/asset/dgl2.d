/*
Copyright (c) 2014-2016 Timur Gafarov 

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module dgl.asset.dgl2;

import std.stdio;
import std.string;
import std.conv;
import std.format;
import std.path;

import dlib.core.memory;
import dlib.core.stream;
import dlib.container.dict;
import dlib.filesystem.filesystem;
import dlib.math.vector;
import dlib.math.quaternion;
import dlib.geometry.triangle;
import dlib.text.lexer;

import dgl.text.dml;
import dgl.graphics.material;
import dgl.graphics.texture;
import dgl.graphics.scene;
import dgl.graphics.entity;
import dgl.graphics.mesh;

import dgl.asset.resource;
import dgl.asset.serialization;

import dgl.text.stringconv;

/*
 * DGL2 is a simple chunk-based binary scene format for DGL. It is a successor of DGL format (DGL1).
 * Main change from DGL1 is the usage of DML (DGL Markup Language) instead of JSON for serializing game-specific properties.
 * DGL2 supports meshes, entities and per-polygon materials with maximum of 8 texture slots.
 * You can create DGL2 scenes in Blender, via our exporter (io_export_dgl2.py).
 */

//version = DGLDebug;

enum ChunkType
{
    HEADER = 0, 
    END = 1,
    TRIMESH = 2,
    MATERIAL = 3,
    ENTITY = 4
}

struct DataChunk
{
    ushort type;
    int id;
    ushort nameSize;
    uint dataSize;
    string name;
    ubyte[] data;

    string toString()
    {
        return format(
            "type = %s\n"
            "id = %s\n"
            "nameSize = %s\n"
            "dataSize = %s\n"
            "name = %s",
            type.to!ChunkType, id,
            nameSize, dataSize, name
        );
    }

    void free()
    {
        if (name.length)
            Delete(name);
        if (data.length)
            Delete(data);
    }
}

struct DGLTriangle
{
    int m;
    Vector3f[3] v;
    Vector3f[3] n;
    Vector2f[3] uv1;
    Vector2f[3] uv2;
}

void calcTriangleData(Triangle* tri, DGLTriangle* dglTri)
{
    tri.v[0] = dglTri.v[0];
    tri.v[1] = dglTri.v[1];
    tri.v[2] = dglTri.v[2];

    tri.n[0] = dglTri.n[0];
    tri.n[1] = dglTri.n[1];
    tri.n[2] = dglTri.n[2];

    tri.t1[0] = dglTri.uv1[0];
    tri.t1[1] = dglTri.uv1[1];
    tri.t1[2] = dglTri.uv1[2];
                
    tri.t2[0] = dglTri.uv2[0];
    tri.t2[1] = dglTri.uv2[1];
    tri.t2[2] = dglTri.uv2[2];
                
    tri.materialIndex = dglTri.m;

    tri.normal = normal(tri.v[0], tri.v[1], tri.v[2]);
                
    tri.barycenter = (tri.v[0] + tri.v[1] + tri.v[2]) / 3;

    tri.d = (tri.v[0].x * tri.normal.x + 
             tri.v[0].y * tri.normal.y + 
             tri.v[0].z * tri.normal.z);

    tri.edges[0] = tri.v[1] - tri.v[0];
    tri.edges[1] = tri.v[2] - tri.v[1];
    tri.edges[2] = tri.v[0] - tri.v[2];
}

class DGLResource: Resource
{
    ResourceManager resourceManager;
    MaterialLibrary materialLib;
    
    Dict!(Mesh, int) meshesById;
    Dict!(Mesh, string) meshesByName;
    Dict!(Entity, int) entitiesById;
    Dict!(Entity, string) entitiesByName;
    
    this(ResourceManager resman)
    {
        resourceManager = resman;
        materialLib = New!MaterialLibrary();
        
        meshesById = New!(Dict!(Mesh, int));
        meshesByName = New!(Dict!(Mesh, string));
        entitiesById = New!(Dict!(Entity, int));
        entitiesByName = New!(Dict!(Entity, string));
    }
    
    Dict!(Material, int) materialsById()
    {
        return materialLib.materialsById;
    }
    
    Dict!(Material, string) materialsByName()
    {
        return materialLib.materialsByName;
    }
    
    void addEntity(int id, string name, Entity e)
    {
        entitiesById[id] = e;
        entitiesByName[copyStr(name)] = e;
    }
    
    void addMesh(int id, string name, Mesh mesh)
    {
        meshesById[id] = mesh;
        meshesByName[copyStr(name)] = mesh;
    }
    
    void addMaterial(int id, string name, Material mat)
    {
        materialLib.addMaterial(id, name, mat);
    }

    bool loadThreadSafePart(InputStream istrm)
    {
        loadDGL2(this, istrm);
        return true;
    }
    
    bool loadThreadUnsafePart()
    {
        foreach(i, e; entitiesById)
        {
            if (e.type == 4)
            {
                if ("mesh" in e.props)
                {
                    string meshName = e.props["mesh"].toString;
                    if (meshName in meshesByName)
                    {
                        Mesh mesh = meshesByName[meshName];
                        
                        if ("genTangents" in e.props)
                            mesh.genTangents = e.props["genTangents"].toBool;
                    }
                }
            }
        }
    
        foreach(i, m; meshesById)
        {
            m.genFaceGroups(materialLib);
        }
        
        foreach(i, e; entitiesById)
        {
            if (e.meshID in meshesById)
                e.model = meshesById[e.meshID];
        }
        
        materialLib.setShader();
        return true;
    }
    
    ~this()
    {
        foreach(name, m; meshesByName)
        {
            Delete(name);
            Delete(m);
        }
        Delete(meshesByName);
        Delete(meshesById);
        
        foreach(name, e; entitiesByName)
        {
            Delete(name);
            Delete(e);
        }
        Delete(entitiesByName);
        Delete(entitiesById);
        
        Delete(materialLib);
    }
}

void loadDGL2(DGLResource res, InputStream istrm)
{
    DataChunk readChunk()
    {
        DataChunk chunk;
        chunk.type = read!ushort(istrm);
        chunk.id = read!int(istrm);
        chunk.nameSize = read!ushort(istrm);
        chunk.dataSize = read!uint(istrm);

        if (chunk.nameSize > 0)
        {
            auto nameData = New!(ubyte[])(chunk.nameSize);
            istrm.fillArray(nameData);
            chunk.name = cast(string)nameData;
        }

        if (chunk.dataSize > 0)
        {
            chunk.data = New!(ubyte[])(chunk.dataSize);
            istrm.fillArray(chunk.data);
        }

        return chunk;
    }

    DataChunk chunk;
    while (chunk.type != ChunkType.END && istrm.readable)
    {
        chunk = readChunk();
        version(DGLDebug) writefln("----\nChunk:\n%s", chunk);

        if (chunk.type == ChunkType.ENTITY)
        {
            Entity e = New!Entity();
            e.id = chunk.id;
            // TODO: duplicate
            //e.name = chunk.name;
            auto dataStrm = New!ArrayStream(chunk.data, chunk.data.length);
            decodeEntity(e, dataStrm, res);
            Delete(dataStrm);
            
            version(DGLDebug) writefln("----\nEntity:\n%s", e);
            
            res.addEntity(e.id, chunk.name, e);
        }
        else if (chunk.type == ChunkType.MATERIAL)
        {
            Material mat = New!Material();
            mat.id = chunk.id;
            // TODO: duplicate
            //mat.name = chunk.name;
            auto dataStrm = New!ArrayStream(chunk.data, chunk.data.length);
            decodeMaterial(mat, dataStrm, res);
            Delete(dataStrm);

            version(DGLDebug) writefln("----\nMaterial:\n%s", mat);
            
            res.addMaterial(mat.id, chunk.name, mat);
        }
        else if (chunk.type == ChunkType.TRIMESH)
        {        
            assert(!(chunk.data.length % DGLTriangle.sizeof)); // Check data integrity
            size_t numTris = chunk.data.length / DGLTriangle.sizeof;
            Triangle[] tris = New!(Triangle[])(numTris);
            auto mtris = cast(DGLTriangle[])chunk.data;
            uint offset = 0;

            foreach(i, mtri; mtris)
            {
                Triangle* tri = &tris[offset];
                calcTriangleData(tri, &mtri);
                offset++;
            }

            Mesh mesh = New!Mesh(tris);
            mesh.id = chunk.id;            
            res.addMesh(mesh.id, chunk.name, mesh);
            
            // TODO: duplicate
            //mesh.name = chunk.name;

            version(DGLDebug) writefln("numTris: %s", numTris);
        }

        chunk.free();
    }

    version(DGLDebug) writeln("end");
}

void decodeEntity(Entity e, InputStream istrm, DGLResource res)
{
    e.type = read!uint(istrm);
    e.materialID = read!int(istrm);
    e.meshID = read!int(istrm);
    
    Vector3f position = read!(Vector3f, true)(istrm);
    Quaternionf rotation = read!(Quaternionf, true)(istrm);
    Vector3f scaling = read!(Vector3f, true)(istrm);
    e.setTransformation(position, rotation, scaling);
    
    DMLData dml;
    auto dmlSize = read!uint(istrm);
    if (dmlSize > 0)
    {
        auto dmlBytes = New!(ubyte[])(dmlSize);
        istrm.fillArray(dmlBytes);
        string dmlStr = cast(string)dmlBytes[0..$];
        version(DGLDebug) writefln("----\ndmlStr:\n%s", dmlStr);
        parseDML(dmlStr, &dml);
        Delete(dmlBytes);
    }
    
    e.props = dml;
    
    if ("visible" in dml.root.data)
        e.visible = dml.root.data["visible"].toBool;
        
    if ("transparent" in dml.root.data)
        e.transparent = dml.root.data["transparent"].toBool;
}

void decodeMaterial(Material m, InputStream istrm, DGLResource res)
{
    DMLData dml;

    auto dmlSize = read!uint(istrm);
    if (dmlSize > 0)
    {
        auto dmlBytes = New!(ubyte[])(dmlSize);
        istrm.fillArray(dmlBytes);
        string dmlStr = cast(string)dmlBytes[0..$];
        version(DGLDebug) writefln("----\ndmlStr:\n%s", dmlStr);
        parseDML(dmlStr, &dml);
        Delete(dmlBytes);
    }

    if ("diffuseColor" in dml.root.data)
    {
        m.diffuseColor = dml.root.data["diffuseColor"].toColor4f;
        if ("emission" in dml.root.data)
        {
            float emission = dml.root.data["emission"].toFloat;
            m.ambientColor = m.diffuseColor * emission;
            m.ambientColor.a = 1.0f;
            m.emissionColor = m.ambientColor;
        }
    }

    if ("specularColor" in dml.root.data)
        m.specularColor = dml.root.data["specularColor"].toColor4f;

    if ("shadeless" in dml.root.data)
        m.shadeless = dml.root.data["shadeless"].toBool;

    if ("texturesNum" in dml.root.data)
    {
        int numTextures = dml.root.data["texturesNum"].toInt;
        foreach(i; 0..numTextures)
        {
            string texId = format("texture%s", i);
            if (texId in dml.root.data)
            {
                string texStr = dml.root.data[texId].toString;
                string filename;
                int blendType;
                formattedRead(texStr, "[%s, %s]", &filename, &blendType);
                auto resman = res.resourceManager;
                Texture tex = null;
                if (filename in resman.resources)
                {
                    tex = resman.getTexture(filename);
                }
                else
                {
                    TextureResource texres = New!TextureResource(resman.imageFactory);
                    resman.loadResourceThreadSafePart(texres, filename);
                    tex = texres.texture;
                    resman.addResource(filename, texres);
                }
                m.textures[i] = tex;
            }
        }
    }
    
    if ("doubleSided" in dml.root.data)
    {
        m.doubleSided = dml.root.data["doubleSided"].toBool;
    }
    
    if ("useGLSL" in dml.root.data)
    {
        m.useGLSL = dml.root.data["useGLSL"].toBool;
    }
    
    if ("blendMode" in dml.root.data)
    {
        m.additiveBlending = (dml.root.data["blendMode"].toInt == 1);
    }
    
    if ("shininess" in dml.root.data)
    {
        m.shininess = dml.root.data["shininess"].toFloat;
    }
    
    if ("rimLight" in dml.root.data)
    {
        m.rimLight = dml.root.data["rimLight"].toBool;
    }

    dml.free();
}

