/*
Copyright (c) 2014 Timur Gafarov 

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module dgl.asset.iqm;

import std.stdio;
import std.conv;
import std.math;

import dlib.core.stream;
import dlib.filesystem.filesystem;
import dlib.math.vector;
import dlib.math.matrix;
import dlib.math.quaternion;
import dlib.math.affine;
import dlib.image.color;
import dlib.image.io.tga;

import dgl.asset.serialization;
import dgl.graphics.material;
import dgl.graphics.texture;

import dgl.asset.animatedmodel;

/*
 * Work-in-progress loader for IQM (InterQuake Format),
 * a modern open format for storing animated models.
 * IQM is designed by Lee Salzman
 * http://sauerbraten.org/iqm
 *
 * Rationale
 * ---------
 * IQM is much like MD5, but far superior in terms of usability.
 * Unlike MD5, it explicitly stores vertex attributes like normals 
 * and tangents in the file, so no need to generate them.
 * Also it has better exporter support in Blender.
 * IQM is supported by a number of notable Open Source engines and games:
 * namely, DarkPlaces, Alien Arena, Xonotic, Warsow and others.
 *
 * Current status and limitations
 * ------------------------------
 * Fully working mesh and animation loading/rendering with normals and texcoords.
 * Lacks several standard features, needs some API improvements.
 * TODO: 
 *  - load tangents and animate them (should be switchable)
 *  - smooth animation switching
 *  - get joint matrix (by name or index) to align weapons/items
 *  - animation blending (?)
 *  - ragdoll support (?)
 *  - facial animation (with voice sync) using morph-target method, 
 *    probably via separate file format (?)
 *  - IK (?)
 */

enum IQM_VERSION = 2;

struct IQMHeader
{
    ubyte[16] magic;
    uint ver;
    uint filesize;
    uint flags;
    uint numText, ofsText;
    uint numMeshes, ofsMeshes;
    uint numVertexArrays, numVertices, ofsVertexArrays;
    uint numTriangles, ofsTriangles, ofsAdjacency;
    uint numJoints, ofsJoints;
    uint numPoses, ofsPoses;
    uint numAnims, ofsAnims;
    uint numFrames, numFrameChannels, ofsFrames, ofsBounds;
    uint numComment, ofsComment;
    uint numExtensions, ofsExtensions;
}

struct IQMVertexArray
{
    uint type;
    uint flags;
    uint format;
    uint size;
    uint offset;
}

alias uint[3] IQMTriangle;

struct IQMJoint
{
    uint name;
    int parent;
    Vector3f translation;
    Quaternionf rotation;
    Vector3f scaling;
}

struct IQMMesh
{
    uint name;
    uint material;
    uint firstVertex, numVertices;
    uint firstTriangle, numTriangles;
}

alias ubyte[4] IQMBlendIndex;
alias ubyte[4] IQMBlendWeight;

enum
{
    IQM_POSITION     = 0,
    IQM_TEXCOORD     = 1,
    IQM_NORMAL       = 2,
    IQM_TANGENT      = 3,
    IQM_BLENDINDEXES = 4,
    IQM_BLENDWEIGHTS = 5,
    IQM_COLOR        = 6,
    IQM_CUSTOM       = 0x10
}

struct IQMPose
{
    int parent;
    uint mask;
    float[10] channelOffset;
    float[10] channelScale;
}

struct IQMAnim
{
    uint name;
    uint firstFrame;
    uint numFrames;
    float framerate;
    uint flags;
}

final class IQMModel: AnimatedModel
{
    Vector3f[] vertices;
    Vector3f[] normals;
    Vector2f[] texcoords;
    IQMBlendIndex[] blendIndices;
    IQMBlendWeight[] blendWeights;

    IQMTriangle[] tris;
    IQMVertexArray[] vas;
    AnimMesh[] _meshes;

    IQMJoint[] joints;

    Matrix4x4f[] baseFrame;
    Matrix4x4f[] invBaseFrame;
    
    Matrix4x4f[] frames;
    
    uint numFrames;

    Material[uint] material;
    
    Animation[string] animations;
    
    this(InputStream istrm, ReadOnlyFileSystem rofs)
    {
        load(istrm, rofs);
    }
    
    void load(InputStream istrm, ReadOnlyFileSystem rofs)
    {
        // Header part
        IQMHeader hdr = istrm.read!(IQMHeader, true);

        version(IQMDebug)
        {
            writefln("hdr.magic: %s", cast(string)hdr.magic);
            writefln("hdr.ver: %s", hdr.ver);
        }
        assert(cast(string)hdr.magic == "INTERQUAKEMODEL\0");
        assert(hdr.ver == IQM_VERSION);

        version(IQMDebug)
        {
            writefln("hdr.numText: %s", hdr.numText);
            writefln("hdr.ofsText: %s", hdr.ofsText);
        }
        
        istrm.setPosition(hdr.ofsText);
        ubyte[] buf = new ubyte[hdr.numText];
        istrm.fillArray(buf);
        
        version(IQMDebug)
            writefln("text:\n%s", cast(string)buf);

        // Vertex data part
        version(IQMDebug)
        {
            writefln("hdr.numVertexArrays: %s", hdr.numVertexArrays);
            writefln("hdr.ofsVertexArrays: %s", hdr.ofsVertexArrays);
        }
        
        this.vas = new IQMVertexArray[hdr.numVertexArrays];
        istrm.setPosition(hdr.ofsVertexArrays);
        foreach(i; 0..hdr.numVertexArrays)
        {
            this.vas[i] = istrm.read!(IQMVertexArray, true);
        }

        foreach(i, va; this.vas)
        {
            version(IQMDebug)
            {
                writefln("Vertex array %s:", i);
                writefln("va.type: %s", va.type);
                writefln("va.flags: %s", va.flags);
                writefln("va.format: %s", va.format);
                writefln("va.size: %s", va.size);
                writefln("va.offset: %s", va.offset);
                writeln("---------------");
            }

            if (va.type == IQM_POSITION)
            {
                assert(va.size == 3);
                // TODO: format asserion
                auto verts = new Vector3f[hdr.numVertices];
                istrm.setPosition(va.offset);
                istrm.fillArray(verts);
                this.vertices ~= verts;
            }
            else if (va.type == IQM_NORMAL)
            {
                assert(va.size == 3);
                // TODO: format asserion
                auto norms = new Vector3f[hdr.numVertices];
                istrm.setPosition(va.offset);
                istrm.fillArray(norms);
                this.normals ~= norms;
            }
            else if (va.type == IQM_TEXCOORD)
            {
                assert(va.size == 2);
                // TODO: format asserion
                auto texcoords = new Vector2f[hdr.numVertices];
                istrm.setPosition(va.offset);
                istrm.fillArray(texcoords);
                this.texcoords ~= texcoords;
            }
            /* TODO: IQM_TANGENT */ 
            else if (va.type == IQM_BLENDINDEXES)
            {
                assert(va.size == 4);
                // TODO: format asserion
                auto bi = new IQMBlendIndex[hdr.numVertices];
                istrm.setPosition(va.offset);
                istrm.fillArray(bi);
                this.blendIndices ~= bi;
            }
            else if (va.type == IQM_BLENDWEIGHTS)
            {
                assert(va.size == 4);
                // TODO: format asserion
                auto bw = new IQMBlendWeight[hdr.numVertices];
                istrm.setPosition(va.offset);
                istrm.fillArray(bw);
                this.blendWeights ~= bw;
            }
        }

        version(IQMDebug)
        {
            writefln("hdr.numTriangles: %s", hdr.numTriangles);
            writefln("hdr.ofsTriangles: %s", hdr.ofsTriangles);
        }

        this.tris = new IQMTriangle[hdr.numTriangles];
        istrm.setPosition(hdr.ofsTriangles);
        foreach(i; 0..hdr.numTriangles)
        {
            this.tris[i] = istrm.read!IQMTriangle;
            uint tmp = this.tris[i][0];
            this.tris[i][0] = this.tris[i][2];
            this.tris[i][2] = tmp;
        }

        version(IQMDebug)
            writefln("hdr.ofsAdjacency: %s", hdr.ofsAdjacency);

        // Skeleton part
        version(IQMDebug)
        {
            writefln("hdr.numJoints: %s", hdr.numJoints);
            writefln("hdr.ofsJoints: %s", hdr.ofsJoints);
        }
        
        this.baseFrame = new Matrix4x4f[hdr.numJoints];
        this.invBaseFrame = new Matrix4x4f[hdr.numJoints];
        istrm.setPosition(hdr.ofsJoints);
        foreach(i; 0..hdr.numJoints)
        {
            IQMJoint j = istrm.read!(IQMJoint, true);

            j.rotation.normalize();
            this.baseFrame[i] = transformationMatrix(j.rotation, j.translation, j.scaling);
            this.invBaseFrame[i] = this.baseFrame[i].inverse;

            if (j.parent >= 0)
            {
                this.baseFrame[i] = this.baseFrame[j.parent] * this.baseFrame[i];
                this.invBaseFrame[i] = this.invBaseFrame[i] * this.invBaseFrame[j.parent];
            }

            assert(validMatrix(this.baseFrame[i]));
            assert(validMatrix(this.invBaseFrame[i]));

            assert(this.baseFrame[i].isAffine);
            assert(this.invBaseFrame[i].isAffine);

            this.joints ~= j;
        }

        // Meshes part
        version(IQMDebug)
        {
            writefln("hdr.numMeshes: %s", hdr.numMeshes);
            writefln("hdr.ofsMeshes: %s", hdr.ofsMeshes);
        }
        this._meshes = new AnimMesh[hdr.numMeshes];
        istrm.setPosition(hdr.ofsMeshes);
        foreach(i; 0..hdr.numMeshes)
        {
            IQMMesh mesh = istrm.read!(IQMMesh, true);

            this._meshes[i] = AnimMesh(
                mesh.material, 
                mesh.firstTriangle,
                mesh.numTriangles);

            // Load texture
            uint matIndex = this._meshes[i].material;
            char* texFilenamePtr = cast(char*)&buf[matIndex];
            string texFilename = to!string(texFilenamePtr);
            version(IQMDebug)
                writefln("material: %s", texFilename);
            auto mat = new Material();
            if (rofs.fileExists(texFilename))
            {
                // TODO: Load by extension
                auto img = loadTGA(rofs.openForInput(texFilename));
                auto tex = new Texture(img);
                mat.textures[0] = tex;
            }
            else if (rofs.fileExists(texFilename ~ ".tga"))
            {
                auto img = loadTGA(rofs.openForInput(texFilename ~ ".tga"));
                auto tex = new Texture(img);
                mat.textures[0] = tex;
            }

            //mat.textures[0] = tex;
            mat.ambientColor = Color4f(1.0f, 1.0f, 1.0f, 1.0f);
            this.material[matIndex] = mat;
        }
    
        // Animation part
    
        // Number of poses should be the same as bindpose joints
        version(IQMDebug)
            writefln("hdr.numPoses: %s", hdr.numPoses);
        assert(hdr.numPoses == hdr.numJoints);

        version(IQMDebug)
        {
            writefln("hdr.numFrames: %s", hdr.numFrames);
            writefln("hdr.numFrameChannels: %s", hdr.numFrameChannels);
        }
        
        // Read poses
        istrm.setPosition(hdr.ofsPoses);
        IQMPose[] poses = new IQMPose[hdr.numPoses];
        foreach(i; 0..hdr.numPoses)
        {
            poses[i] = istrm.read!(IQMPose, true);
        }

        // Read frames
        this.numFrames = hdr.numFrames;
        this.frames = new Matrix4x4f[hdr.numFrames * hdr.numPoses];
        istrm.setPosition(hdr.ofsFrames);
        uint fi = 0;
        foreach(i; 0..hdr.numFrames)
        foreach(j; 0..hdr.numPoses)
        {
            auto p = &poses[j];
            
            Vector3f trans, scale;
            Quaternionf rot;
            trans.x = p.channelOffset[0]; if (p.mask & 0x01) trans.x += istrm.read!(ushort, true) * p.channelScale[0];
            trans.y = p.channelOffset[1]; if (p.mask & 0x02) trans.y += istrm.read!(ushort, true) * p.channelScale[1];
            trans.z = p.channelOffset[2]; if (p.mask & 0x04) trans.z += istrm.read!(ushort, true) * p.channelScale[2];
            rot.x = p.channelOffset[3]; if(p.mask&0x08) rot.x += istrm.read!(ushort, true) * p.channelScale[3];
            rot.y = p.channelOffset[4]; if(p.mask&0x10) rot.y += istrm.read!(ushort, true) * p.channelScale[4];
            rot.z = p.channelOffset[5]; if(p.mask&0x20) rot.z += istrm.read!(ushort, true) * p.channelScale[5];
            rot.w = p.channelOffset[6]; if(p.mask&0x40) rot.w += istrm.read!(ushort, true) * p.channelScale[6];
            scale.x = p.channelOffset[7]; if(p.mask&0x80) scale.x += istrm.read!(ushort, true) * p.channelScale[7];
            scale.y = p.channelOffset[8]; if(p.mask&0x100) scale.y += istrm.read!(ushort, true) * p.channelScale[8];
            scale.z = p.channelOffset[9]; if(p.mask&0x200) scale.z += istrm.read!(ushort, true) * p.channelScale[9];
            
            rot.normalize();            
            Matrix4x4f m = transformationMatrix(rot, trans, scale);
            assert(validMatrix(m));
            
            // Concatenate each pose with the inverse base pose to avoid doing this at animation time.
            // If the joint has a parent, then it needs to be pre-concatenated with its parent's base pose.
            if (p.parent >= 0)
                this.frames[i * hdr.numPoses + j] = 
                    this.baseFrame[p.parent] * m * this.invBaseFrame[j];
            else 
                this.frames[i * hdr.numPoses + j] = m * this.invBaseFrame[j];
        }
    
        // Read animations
        istrm.setPosition(hdr.ofsAnims);
        foreach(i; 0..hdr.numAnims)
        {
            IQMAnim anim = istrm.read!(IQMAnim, true);
        
            char* namePtr = cast(char*)&buf[anim.name];
            string name = to!string(namePtr);
            //writeln(name);
        
            Animation a = Animation(
                anim.firstFrame,
                anim.numFrames,
                anim.framerate
            );
        
            this.animations[name] = a;
        }
    }

/*
    void calcBindPose()
    {
        Matrix4x4f[] frame = new Matrix4x4f[joints.length];
        foreach(i, ref j; joints)
        {
            frame[i] = baseFrame[i] * invBaseFrame[i];
        }

        foreach(i, v; vertices)
        {
            auto bi = blendIndices[i];
            auto bw = blendWeights[i];

            float w = (cast(float)bw[0])/255.0f;
            Matrix4x4f mat = multScalarAffine(frame[bi[0]], w);

            for (uint j = 1; j < 4 && bw[j] > 0.0; j++)
            {
                w = (cast(float)bw[j])/255.0f;
                auto tmp = multScalarAffine(frame[bi[j]], w);
                mat = addMatrixAffine(mat, tmp);
            }

            assert(validMatrix(mat));
            assert(mat.isAffine);

            resVertices[i] = vertices[i] * mat;
            resNormals[i] = normals[i] * matrix4x4to3x3(mat);
            resNormals[i].normalize();
        }
    }
*/

    override AnimMesh[] meshes()
    {
        return _meshes;
    }
    
    override Material[uint] materials()
    {
        return material;
    }

    override ActorData genActorData()
    {
        ActorData data;
        data.vertices = new Vector3f[vertices.length];
        data.normals = new Vector3f[normals.length];
        data.texcoords = texcoords;
        data.tris = tris;
        data.frame = new Matrix4x4f[joints.length];
        return data;
    }

    void calcAnimFrame(
        uint f1, 
        uint f2, 
        float t, 
        ActorData* data)
    {            
        Matrix4x4f* mat1 = &frames[f1 * joints.length];
        Matrix4x4f* mat2 = &frames[f2 * joints.length];
        
        // Interpolate between two frames
        foreach(i, ref j; joints)
        {
            Matrix4x4f mat = mat1[i] * (1.0f - t) + mat2[i] * t;
            if (j.parent >= 0)
                data.frame[i] = data.frame[j.parent] * mat;
            else
                data.frame[i] = mat;
        }
        
        // Update VBO
        foreach(i, v; vertices)
        {
            auto bi = blendIndices[i];
            auto bw = blendWeights[i];

            float w = (cast(float)bw[0])/255.0f;
            Matrix4x4f mat = multScalarAffine(data.frame[bi[0]], w);
            
            for (uint j = 1; j < 4 && bw[j] > 0.0; j++)
            {
                w = (cast(float)bw[j])/255.0f;
                auto tmp = multScalarAffine(data.frame[bi[j]], w);
                mat = addMatrixAffine(mat, tmp);
            }

            assert(validMatrix(mat));
            assert(mat.isAffine);

            data.vertices[i] = vertices[i] * mat;
            data.normals[i] = normals[i] * matrix4x4to3x3(mat);
            data.normals[i].normalize();
        }
    }
    
    override void setAnimation(string name, ActorState* state)
    {
        if (!(name in animations))
            return;
        state.anim = &animations[name];
        state.frame1 = state.anim.firstFrame;
        state.frame2 = state.frame1 + 1;
        if (state.frame2 == numFrames)
            state.frame2 = 0;
        state.t = 0.0f; // TODO: smooth animation switch
    }
    
    override void updateAnimation(double dt, ActorData* data, ActorState* state)
    {
        calcAnimFrame(state.frame1, state.frame2, state.t, data);
        float frameRate = 24.0f;
        if (state.anim !is null)
            frameRate = state.anim.framerate;
        float tdiff = dt * frameRate;
        state.t += tdiff;
        if (state.t >= 1.0f)
        {
            state.t = 0.0f;
            state.frame1++;
            state.frame2++;
            
            if (state.anim !is null)
            if (state.frame1 == state.anim.firstFrame + state.anim.numFrames)
            {
                state.frame1 = state.anim.firstFrame;
                state.frame2 = state.frame1 + 1;
            }
            
            if (state.frame2 == numFrames)
                state.frame2 = 0;
            if (state.frame1 == numFrames)
                state.frame1 = 0;
        }
    }
}

// TODO: move this to dlib.filesystem.filesystem
bool fileExists(ReadOnlyFileSystem rofs, string filename)
{
    FileStat stat;
    return rofs.stat(filename, stat);
}

// TODO: move this to dlib.math.affine
Matrix4x4f transformationMatrix(Quaternionf r, Vector3f t, Vector3f s)
{
    Matrix4x4f res = Matrix4x4f.identity;
    Matrix3x3f rm = r.toMatrix3x3;
    res.a11 = rm.a11 * s.x; res.a12 = rm.a12 * s.x; res.a13 = rm.a13 * s.x;
    res.a21 = rm.a21 * s.y; res.a22 = rm.a22 * s.y; res.a23 = rm.a23 * s.y;
    res.a31 = rm.a31 * s.z; res.a32 = rm.a32 * s.z; res.a33 = rm.a33 * s.z;
    res.a14 = t.x;
    res.a24 = t.y;
    res.a34 = t.z;
    return res;
}

// TODO: move this to dlib.math.affine
Matrix4x4f multScalarAffine(Matrix4x4f m, float s)
{
    Matrix4x4f res = m;
    res.a11 *= s; res.a12 *= s; res.a13 *= s;
    res.a21 *= s; res.a22 *= s; res.a23 *= s;
    res.a31 *= s; res.a32 *= s; res.a33 *= s;
    res.a14 *= s;
    res.a24 *= s;
    res.a34 *= s;
    return res;
}

// TODO: move this to dlib.math.affine
Matrix4x4f addMatrixAffine(Matrix4x4f m1, Matrix4x4f m2)
{
    Matrix4x4f res = m1;
    res.a11 += m2.a11; res.a12 += m2.a12; res.a13 += m2.a13;
    res.a21 += m2.a21; res.a22 += m2.a22; res.a23 += m2.a23;
    res.a31 += m2.a31; res.a32 += m2.a32; res.a33 += m2.a33;
    res.a14 += m2.a14;
    res.a24 += m2.a24;
    res.a34 += m2.a34;
    return res;
}

// TODO: move this to dlib.math.matrix
bool validMatrix(T, size_t N)(Matrix!(T, N) m)
{
    foreach (v; m.arrayof)
        if (isnan(v))
            return false;
    return true;
}

// TODO: move this to dlib.math.vector
bool validVector(T, size_t N)(Vector!(T, N) vec)
{
    foreach (v; vec.arrayof)
        if (isnan(v))
            return false;
    return true;
}
